/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import Critters from 'critters';
import * as fs from 'fs';
/**
 * Pattern used to extract the media query set by Critters in an `onload` handler.
 */
const MEDIA_SET_HANDLER_PATTERN = /^this\.media=[&apos;"'](.*)[&apos;"'];?$/;
/**
 * Name of the attribute used to save the Critters media query so it can be re-assigned on load.
 */
const CSP_MEDIA_ATTR = 'ngCspMedia';
/**
 * Script text used to change the media value of the link tags.
 */
const LINK_LOAD_SCRIPT_CONTENT = [
    `(() => {`,
    // Save the `children` in a variable since they're a live DOM node collection.
    // We iterate over the direct descendants, instead of going through a `querySelectorAll`,
    // because we know that the tags will be directly inside the `head`.
    `  const children = document.head.children;`,
    // Declare `onLoad` outside the loop to avoid leaking memory.
    // Can't be an arrow function, because we need `this` to refer to the DOM node.
    `  function onLoad() {this.media = this.getAttribute('${CSP_MEDIA_ATTR}');}`,
    // Has to use a plain for loop, because some browsers don't support
    // `forEach` on `children` which is a `HTMLCollection`.
    `  for (let i = 0; i < children.length; i++) {`,
    `    const child = children[i];`,
    `    child.hasAttribute('${CSP_MEDIA_ATTR}') && child.addEventListener('load', onLoad);`,
    `  }`,
    `})();`,
].join('\n');
class CrittersExtended extends Critters {
    constructor(optionsExtended, resourceCache) {
        super({
            logger: {
                warn: (s) => this.warnings.push(s),
                error: (s) => this.errors.push(s),
                info: () => { },
            },
            logLevel: 'warn',
            path: optionsExtended.outputPath,
            publicPath: optionsExtended.deployUrl,
            compress: !!optionsExtended.minify,
            pruneSource: false,
            reduceInlineStyles: false,
            mergeStylesheets: false,
            // Note: if `preload` changes to anything other than `media`, the logic in
            // `embedLinkedStylesheetOverride` will have to be updated.
            preload: 'media',
            noscriptFallback: true,
            inlineFonts: true,
        });
        this.optionsExtended = optionsExtended;
        this.resourceCache = resourceCache;
        this.warnings = [];
        this.errors = [];
        this.addedCspScriptsDocuments = new WeakSet();
        this.documentNonces = new WeakMap();
        /**
         * Override of the Critters `embedLinkedStylesheet` method
         * that makes it work with Angular's CSP APIs.
         */
        this.embedLinkedStylesheetOverride = async (link, document) => {
            const returnValue = await this.initialEmbedLinkedStylesheet(link, document);
            const cspNonce = this.findCspNonce(document);
            if (cspNonce) {
                const crittersMedia = link.getAttribute('onload')?.match(MEDIA_SET_HANDLER_PATTERN);
                if (crittersMedia) {
                    // If there's a Critters-generated `onload` handler and the file has an Angular CSP nonce,
                    // we have to remove the handler, because it's incompatible with CSP. We save the value
                    // in a different attribute and we generate a script tag with the nonce that uses
                    // `addEventListener` to apply the media query instead.
                    link.removeAttribute('onload');
                    link.setAttribute(CSP_MEDIA_ATTR, crittersMedia[1]);
                    this.conditionallyInsertCspLoadingScript(document, cspNonce);
                }
                link.prev?.setAttribute('nonce', cspNonce);
            }
            return returnValue;
        };
        // We can't use inheritance to override `embedLinkedStylesheet`, because it's not declared in
        // the `Critters` .d.ts which means that we can't call the `super` implementation. TS doesn't
        // allow for `super` to be cast to a different type.
        this.initialEmbedLinkedStylesheet = this.embedLinkedStylesheet;
        this.embedLinkedStylesheet = this.embedLinkedStylesheetOverride;
    }
    async readFile(path) {
        let resourceContent = this.resourceCache.get(path);
        if (resourceContent === undefined) {
            resourceContent = await fs.promises.readFile(path, 'utf-8');
            this.resourceCache.set(path, resourceContent);
        }
        return resourceContent;
    }
    /**
     * Finds the CSP nonce for a specific document.
     */
    findCspNonce(document) {
        if (this.documentNonces.has(document)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return this.documentNonces.get(document);
        }
        // HTML attribute are case-insensitive, but the parser used by Critters is case-sensitive.
        const nonceElement = document.querySelector('[ngCspNonce], [ngcspnonce]');
        const cspNonce = nonceElement?.getAttribute('ngCspNonce') || nonceElement?.getAttribute('ngcspnonce') || null;
        this.documentNonces.set(document, cspNonce);
        return cspNonce;
    }
    /**
     * Inserts the `script` tag that swaps the critical CSS at runtime,
     * if one hasn't been inserted into the document already.
     */
    conditionallyInsertCspLoadingScript(document, nonce) {
        if (this.addedCspScriptsDocuments.has(document)) {
            return;
        }
        if (document.head.textContent.includes(LINK_LOAD_SCRIPT_CONTENT)) {
            // Script was already added during the build.
            this.addedCspScriptsDocuments.add(document);
            return;
        }
        const script = document.createElement('script');
        script.setAttribute('nonce', nonce);
        script.textContent = LINK_LOAD_SCRIPT_CONTENT;
        // Append the script to the head since it needs to
        // run as early as possible, after the `link` tags.
        document.head.appendChild(script);
        this.addedCspScriptsDocuments.add(document);
    }
}
export class InlineCriticalCssProcessor {
    constructor(options) {
        this.options = options;
        this.resourceCache = new Map();
    }
    async process(html, options) {
        const critters = new CrittersExtended({ ...this.options, ...options }, this.resourceCache);
        const content = await critters.process(html);
        return {
            content,
            errors: critters.errors.length ? critters.errors : undefined,
            warnings: critters.warnings.length ? critters.warnings : undefined,
        };
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5saW5lLWNzcy1wcm9jZXNzb3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9tb2R1bGVzL2NvbW1vbi90b29scy9zcmMvaW5saW5lLWNzcy1wcm9jZXNzb3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HO0FBRUgsT0FBTyxRQUFRLE1BQU0sVUFBVSxDQUFDO0FBQ2hDLE9BQU8sS0FBSyxFQUFFLE1BQU0sSUFBSSxDQUFDO0FBRXpCOztHQUVHO0FBQ0gsTUFBTSx5QkFBeUIsR0FBRywwQ0FBMEMsQ0FBQztBQUU3RTs7R0FFRztBQUNILE1BQU0sY0FBYyxHQUFHLFlBQVksQ0FBQztBQUVwQzs7R0FFRztBQUNILE1BQU0sd0JBQXdCLEdBQUc7SUFDL0IsVUFBVTtJQUNWLDhFQUE4RTtJQUM5RSx5RkFBeUY7SUFDekYsb0VBQW9FO0lBQ3BFLDRDQUE0QztJQUM1Qyw2REFBNkQ7SUFDN0QsK0VBQStFO0lBQy9FLHdEQUF3RCxjQUFjLE1BQU07SUFDNUUsbUVBQW1FO0lBQ25FLHVEQUF1RDtJQUN2RCwrQ0FBK0M7SUFDL0MsZ0NBQWdDO0lBQ2hDLDJCQUEyQixjQUFjLCtDQUErQztJQUN4RixLQUFLO0lBQ0wsT0FBTztDQUNSLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBNENiLE1BQU0sZ0JBQWlCLFNBQVEsUUFBUTtJQVVyQyxZQUNXLGVBQW9GLEVBQzVFLGFBQWtDO1FBRW5ELEtBQUssQ0FBQztZQUNKLE1BQU0sRUFBRTtnQkFDTixJQUFJLEVBQUUsQ0FBQyxDQUFTLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztnQkFDMUMsS0FBSyxFQUFFLENBQUMsQ0FBUyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7Z0JBQ3pDLElBQUksRUFBRSxHQUFHLEVBQUUsR0FBRSxD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LEtBQUssQ0FBQyxPQUFPLENBQ1gsSUFBWSxFQUNaLE9BQXdDO1FBRXhDLE1BQU0sUUFBUSxHQUFHLElBQUksZ0JBQWdCLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQyxPQUFPLEVBQUUsR0FBRyxPQUFPLEVBQUUsRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDM0YsTUFBTSxPQUFPLEdBQUcsTUFBTSxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRTdDLE9BQU87WUFDTCxPQUFPO1lBQ1AsTUFBTSxFQUFFLFFBQVEsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxTQUFTO1lBQzVELFFBQVEsRUFBRSxRQUFRLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsU0FBUztTQUNuRSxDQUFDO0lBQ0osQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCBDcml0dGVycyBmcm9tICdjcml0dGVycyc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5cbi8qKlxuICogUGF0dGVybiB1c2VkIHRvIGV4dHJhY3QgdGhlIG1lZGlhIHF1ZXJ5IHNldCBieSBDcml0dGVycyBpbiBhbiBgb25sb2FkYCBoYW5kbGVyLlxuICovXG5jb25zdCBNRURJQV9TRVRfSEFORExFUl9QQVRURVJOID0gL150aGlzXFwubWVkaWE9WyZhcG9zO1wiJ10oLiopWyZhcG9zO1wiJ107PyQvO1xuXG4vKipcbiAqIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB1c2VkIHRvIHNhdmUgdGhlIENyaXR0ZXJzIG1lZGlhIHF1ZXJ5IHNvIGl0IGNhbiBiZSByZS1hc3NpZ25lZCBvbiBsb2FkLlxuICovXG5jb25zdCBDU1BfTUVESUFfQVRUUiA9ICduZ0NzcE1lZGlhJztcblxuLyoqXG4gKiBTY3JpcHQgdGV4dCB1c2VkIHRvIGNoYW5nZSB0aGUgbWVkaWEgdmFsdWUgb2YgdGhlIGxpbmsgdGFncy5cbiAqL1xuY29uc3QgTElOS19MT0FEX1NDUklQVF9DT05URU5UID0gW1xuICBgKCgpID0+IHtgLFxuICAvLyBTYXZlIHRoZSBgY2hpbGRyZW5gIGluIGEgdmFyaWFibGUgc2luY2UgdGhleSdyZSBhIGxpdmUgRE9NIG5vZGUgY29sbGVjdGlvbi5cbiAgLy8gV2UgaXRlcmF0ZSBvdmVyIHRoZSBkaXJlY3QgZGVzY2VuZGFudHMsIGluc3RlYWQgb2YgZ29pbmcgdGhyb3VnaCBhIGBxdWVyeVNlbGVjdG9yQWxsYCxcbiAgLy8gYmVjYXVzZSB3ZSBrbm93IHRoYXQgdGhlIHRhZ3Mgd2lsbCBiZSBkaXJlY3RseSBpbnNpZGUgdGhlIGBoZWFkYC5cbiAgYCAgY29uc3QgY2hpbGRyZW4gPSBkb2N1bWVudC5oZWFkLmNoaWxkcmVuO2AsXG4gIC8vIERlY2xhcmUgYG9uTG9hZGAgb3V0c2lkZSB0aGUgbG9vcCB0byBhdm9pZCBsZWFraW5nIG1lbW9yeS5cbiAgLy8gQ2FuJ3QgYmUgYW4gYXJyb3cgZnVuY3Rpb24sIGJlY2F1c2Ugd2UgbmVlZCBgdGhpc2AgdG8gcmVmZXIgdG8gdGhlIERPTSBub2RlLlxuICBgICBmdW5jdGlvbiBvbkxvYWQoKSB7dGhpcy5tZWRpYSA9IHRoaXMuZ2V0QXR0cmlidXRlKCcke0NTUF9NRURJQV9BVFRSfScpO31gLFxuICAvLyBIYXMgdG8gdXNlIGEgcGxhaW4gZm9yIGxvb3AsIGJlY2F1c2Ugc29tZSBicm93c2VycyBkb24ndCBzdXBwb3J0XG4gIC8vIGBmb3JFYWNoYCBvbiBgY2hpbGRyZW5gIHdoaWNoIGlzIGEgYEhUTUxDb2xsZWN0aW9uYC5cbiAgYCAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge2AsXG4gIGAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtgLFxuICBgICAgIGNoaWxkLmhhc0F0dHJpYnV0ZSgnJHtDU1BfTUVESUFfQVRUUn0nKSAmJiBjaGlsZC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkKTtgLFxuICBgICB9YCxcbiAgYH0pKCk7YCxcbl0uam9pbignXFxuJyk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5saW5lQ3JpdGljYWxDc3NQcm9jZXNzT3B0aW9ucyB7XG4gIG91dHB1dFBhdGg/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5saW5lQ3JpdGljYWxDc3NQcm9jZXNzb3JPcHRpb25zIHtcbiAgbWluaWZ5PzogYm9vbGVhbjtcbiAgZGVwbG95VXJsPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElubGluZUNyaXRpY2FsQ3NzUmVzdWx0IHtcbiAgY29udGVudDogc3RyaW5nO1xuICB3YXJuaW5ncz86IHN0cmluZ1tdO1xuICBlcnJvcnM/OiBzdHJpbmdbXTtcbn1cblxuLyoqIFBhcnRpYWwgcmVwcmVzZW50YXRpb24gb2YgYW4gYEhUTUxFbGVtZW50YC4gKi9cbmludGVyZmFjZSBQYXJ0aWFsSFRNTEVsZW1lbnQge1xuICBnZXRBdHRyaWJ1dGUobmFtZTogc3RyaW5nKTogc3RyaW5nIHwgbnVsbDtcbiAgc2V0QXR0cmlidXRlKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyk6IHZvaWQ7XG4gIGhhc0F0dHJpYnV0ZShuYW1lOiBzdHJpbmcpOiBib29sZWFuO1xuICByZW1vdmVBdHRyaWJ1dGUobmFtZTogc3RyaW5nKTogdm9pZDtcbiAgYXBwZW5kQ2hpbGQoY2hpbGQ6IFBhcnRpYWxIVE1MRWxlbWVudCk6IHZvaWQ7XG4gIHRleHRDb250ZW50OiBzdHJpbmc7XG4gIHRhZ05hbWU6IHN0cmluZyB8IG51bGw7XG4gIGNoaWxkcmVuOiBQYXJ0aWFsSFRNTEVsZW1lbnRbXTtcbiAgbmV4dDogUGFydGlhbEhUTUxFbGVtZW50IHwgbnVsbDtcbiAgcHJldjogUGFydGlhbEhUTUxFbGVtZW50IHwgbnVsbDtcbn1cblxuLyoqIFBhcnRpYWwgcmVwcmVzZW50YXRpb24gb2YgYW4gSFRNTCBgRG9jdW1lbnRgLiAqL1xuaW50ZXJmYWNlIFBhcnRpYWxEb2N1bWVudCB7XG4gIGhlYWQ6IFBhcnRpYWxIVE1MRWxlbWVudDtcbiAgY3JlYXRlRWxlbWVudCh0YWdOYW1lOiBzdHJpbmcpOiBQYXJ0aWFsSFRNTEVsZW1lbnQ7XG4gIHF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3I6IHN0cmluZyk6IFBhcnRpYWxIVE1MRWxlbWVudCB8IG51bGw7XG59XG5cbi8qKiBTaWduYXR1cmUgb2YgdGhlIGBDcml0dGVycy5lbWJlZExpbmtlZFN0eWxlc2hlZXRgIG1ldGhvZC4gKi9cbnR5cGUgRW1iZWRMaW5rZWRTdHlsZXNoZWV0Rm4gPSAoXG4gIGxpbms6IFBhcnRpYWxIVE1MRWxlbWVudCxcbiAgZG9jdW1lbnQ6IFBhcnRpYWxEb2N1bWVudCxcbikgPT4gUHJvbWlzZTx1bmtub3duPjtcblxuY2xhc3MgQ3JpdHRlcnNFeHRlbmRlZCBleHRlbmRzIENyaXR0ZXJzIHtcbiAgcmVhZG9ubHkgd2FybmluZ3M6IHN0cmluZ1tdID0gW107XG4gIHJlYWRvbmx5IGVycm9yczogc3RyaW5nW10gPSBbXTtcbiAgcHJpdmF0ZSBpbml0aWFsRW1iZWRMaW5rZWRTdHlsZXNoZWV0OiBFbWJlZExpbmtlZFN0eWxlc2hlZXRGbjtcbiAgcHJpdmF0ZSBhZGRlZENzcFNjcmlwdHNEb2N1bWVudHMgPSBuZXcgV2Vha1NldDxQYXJ0aWFsRG9jdW1lbnQ+KCk7XG4gIHByaXZhdGUgZG9jdW1lbnROb25jZXMgPSBuZXcgV2Vha01hcDxQYXJ0aWFsRG9jdW1lbnQsIHN0cmluZyB8IG51bGw+KCk7XG5cbiAgLy8gSW5oZXJpdGVkIGZyb20gYENyaXR0ZXJzYCwgYnV0IG5vdCBleHBvc2VkIGluIHRoZSB0eXBpbmdzLlxuICBwcm90ZWN0ZWQgZW1iZWRMaW5rZWRTdHlsZXNoZWV0ITogRW1iZWRMaW5rZWRTdHlsZXNoZWV0Rm47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcmVhZG9ubHkgb3B0aW9uc0V4dGVuZGVkOiBJbmxpbmVDcml0aWNhbENzc1Byb2Nlc3Nvck9wdGlvbnMgJiBJbmxpbmVDcml0aWNhbENzc1Byb2Nlc3NPcHRpb25zLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgcmVzb3VyY2VDYWNoZTogTWFwPHN0cmluZywgc3RyaW5nPixcbiAgKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbG9nZ2VyOiB7XG4gICAgICAgIHdhcm46IChzOiBzdHJpbmcpID0+IHRoaXMud2FybmluZ3MucHVzaChzKSxcbiAgICAgICAgZXJyb3I6IChzOiBzdHJpbmcpID0+IHRoaXMuZXJyb3JzLnB1c2gocyksXG4gICAgICAgIGluZm86ICgpID0+IHt9LFxuICAgICAgfSxcbiAgICAgIGxvZ0xldmVsOiAnd2FybicsXG4gICAgICBwYXRoOiBvcHRpb25zRXh0ZW5kZWQub3V0cHV0UGF0aCxcbiAgICAgIHB1YmxpY1BhdGg6IG9wdGlvbnNFeHRlbmRlZC5kZXBsb3lVcmwsXG4gICAgICBjb21wcmVzczogISFvcHRpb25zRXh0ZW5kZWQubWluaWZ5LFxuICAgICAgcHJ1bmVTb3VyY2U6IGZhbHNlLFxuICAgICAgcmVkdWNlSW5saW5lU3R5bGVzOiBmYWxzZSxcbiAgICAgIG1lcmdlU3R5bGVzaGVldHM6IGZhbHNlLFxuICAgICAgLy8gTm90ZTogaWYgYHByZWxvYWRgIGNoYW5nZXMgdG8gYW55dGhpbmcgb3RoZXIgdGhhbiBgbWVkaWFgLCB0aGUgbG9naWMgaW5cbiAgICAgIC8vIGBlbWJlZExpbmtlZFN0eWxlc2hlZXRPdmVycmlkZWAgd2lsbCBoYXZlIHRvIGJlIHVwZGF0ZWQuXG4gICAgICBwcmVsb2FkOiAnbWVkaWEnLFxuICAgICAgbm9zY3JpcHRGYWxsYmFjazogdHJ1ZSxcbiAgICAgIGlubGluZUZvbnRzOiB0cnVlLFxuICAgIH0pO1xuXG4gICAgLy8gV2UgY2FuJ3QgdXNlIGluaGVyaXRhbmNlIHRvIG92ZXJyaWRlIGBlbWJlZExpbmtlZFN0eWxlc2hlZXRgLCBiZWNhdXNlIGl0J3Mgbm90IGRlY2xhcmVkIGluXG4gICAgLy8gdGhlIGBDcml0dGVyc2AgLmQudHMgd2hpY2ggbWVhbnMgdGhhdCB3ZSBjYW4ndCBjYWxsIHRoZSBgc3VwZXJgIGltcGxlbWVudGF0aW9uLiBUUyBkb2Vzbid0XG4gICAgLy8gYWxsb3cgZm9yIGBzdXBlcmAgdG8gYmUgY2FzdCB0byBhIGRpZmZlcmVudCB0eXBlLlxuICAgIHRoaXMuaW5pdGlhbEVtYmVkTGlua2VkU3R5bGVzaGVldCA9IHRoaXMuZW1iZWRMaW5rZWRTdHlsZXNoZWV0O1xuICAgIHRoaXMuZW1iZWRMaW5rZWRTdHlsZXNoZWV0ID0gdGhpcy5lbWJlZExpbmtlZFN0eWxlc2hlZXRPdmVycmlkZTtcbiAgfVxuXG4gIHB1YmxpYyBvdmVycmlkZSBhc3luYyByZWFkRmlsZShwYXRoOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGxldCByZXNvdXJjZUNvbnRlbnQgPSB0aGlzLnJlc291cmNlQ2FjaGUuZ2V0KHBhdGgpO1xuICAgIGlmIChyZXNvdXJjZUNvbnRlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVzb3VyY2VDb250ZW50ID0gYXdhaXQgZnMucHJvbWlzZXMucmVhZEZpbGUocGF0aCwgJ3V0Zi04Jyk7XG4gICAgICB0aGlzLnJlc291cmNlQ2FjaGUuc2V0KHBhdGgsIHJlc291cmNlQ29udGVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc291cmNlQ29udGVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvZiB0aGUgQ3JpdHRlcnMgYGVtYmVkTGlua2VkU3R5bGVzaGVldGAgbWV0aG9kXG4gICAqIHRoYXQgbWFrZXMgaXQgd29yayB3aXRoIEFuZ3VsYXIncyBDU1AgQVBJcy5cbiAgICovXG4gIHByaXZhdGUgZW1iZWRMaW5rZWRTdHlsZXNoZWV0T3ZlcnJpZGU6IEVtYmVkTGlua2VkU3R5bGVzaGVldEZuID0gYXN5bmMgKGxpbmssIGRvY3VtZW50KSA9PiB7XG4gICAgY29uc3QgcmV0dXJuVmFsdWUgPSBhd2FpdCB0aGlzLmluaXRpYWxFbWJlZExpbmtlZFN0eWxlc2hlZXQobGluaywgZG9jdW1lbnQpO1xuICAgIGNvbnN0IGNzcE5vbmNlID0gdGhpcy5maW5kQ3NwTm9uY2UoZG9jdW1lbnQpO1xuXG4gICAgaWYgKGNzcE5vbmNlKSB7XG4gICAgICBjb25zdCBjcml0dGVyc01lZGlhID0gbGluay5nZXRBdHRyaWJ1dGUoJ29ubG9hZCcpPy5tYXRjaChNRURJQV9TRVRfSEFORExFUl9QQVRURVJOKTtcblxuICAgICAgaWYgKGNyaXR0ZXJzTWVkaWEpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBhIENyaXR0ZXJzLWdlbmVyYXRlZCBgb25sb2FkYCBoYW5kbGVyIGFuZCB0aGUgZmlsZSBoYXMgYW4gQW5ndWxhciBDU1Agbm9uY2UsXG4gICAgICAgIC8vIHdlIGhhdmUgdG8gcmVtb3ZlIHRoZSBoYW5kbGVyLCBiZWNhdXNlIGl0J3MgaW5jb21wYXRpYmxlIHdpdGggQ1NQLiBXZSBzYXZlIHRoZSB2YWx1ZVxuICAgICAgICAvLyBpbiBhIGRpZmZlcmVudCBhdHRyaWJ1dGUgYW5kIHdlIGdlbmVyYXRlIGEgc2NyaXB0IHRhZyB3aXRoIHRoZSBub25jZSB0aGF0IHVzZXNcbiAgICAgICAgLy8gYGFkZEV2ZW50TGlzdGVuZXJgIHRvIGFwcGx5IHRoZSBtZWRpYSBxdWVyeSBpbnN0ZWFkLlxuICAgICAgICBsaW5rLnJlbW92ZUF0dHJpYnV0ZSgnb25sb2FkJyk7XG4gICAgICAgIGxpbmsuc2V0QXR0cmlidXRlKENTUF9NRURJQV9BVFRSLCBjcml0dGVyc01lZGlhWzFdKTtcbiAgICAgICAgdGhpcy5jb25kaXRpb25hbGx5SW5zZXJ0Q3NwTG9hZGluZ1NjcmlwdChkb2N1bWVudCwgY3NwTm9uY2UpO1xuICAgICAgfVxuXG4gICAgICBsaW5rLnByZXY/LnNldEF0dHJpYnV0ZSgnbm9uY2UnLCBjc3BOb25jZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaW5kcyB0aGUgQ1NQIG5vbmNlIGZvciBhIHNwZWNpZmljIGRvY3VtZW50LlxuICAgKi9cbiAgcHJpdmF0ZSBmaW5kQ3NwTm9uY2UoZG9jdW1lbnQ6IFBhcnRpYWxEb2N1bWVudCk6IHN0cmluZyB8IG51bGwge1xuICAgIGlmICh0aGlzLmRvY3VtZW50Tm9uY2VzLmhhcyhkb2N1bWVudCkpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICByZXR1cm4gdGhpcy5kb2N1bWVudE5vbmNlcy5nZXQoZG9jdW1lbnQpITtcbiAgICB9XG5cbiAgICAvLyBIVE1MIGF0dHJpYnV0ZSBhcmUgY2FzZS1pbnNlbnNpdGl2ZSwgYnV0IHRoZSBwYXJzZXIgdXNlZCBieSBDcml0dGVycyBpcyBjYXNlLXNlbnNpdGl2ZS5cbiAgICBjb25zdCBub25jZUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbbmdDc3BOb25jZV0sIFtuZ2NzcG5vbmNlXScpO1xuICAgIGNvbnN0IGNzcE5vbmNlID1cbiAgICAgIG5vbmNlRWxlbWVudD8uZ2V0QXR0cmlidXRlKCduZ0NzcE5vbmNlJykgfHwgbm9uY2VFbGVtZW50Py5nZXRBdHRyaWJ1dGUoJ25nY3Nwbm9uY2UnKSB8fCBudWxsO1xuXG4gICAgdGhpcy5kb2N1bWVudE5vbmNlcy5zZXQoZG9jdW1lbnQsIGNzcE5vbmNlKTtcblxuICAgIHJldHVybiBjc3BOb25jZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIHRoZSBgc2NyaXB0YCB0YWcgdGhhdCBzd2FwcyB0aGUgY3JpdGljYWwgQ1NTIGF0IHJ1bnRpbWUsXG4gICAqIGlmIG9uZSBoYXNuJ3QgYmVlbiBpbnNlcnRlZCBpbnRvIHRoZSBkb2N1bWVudCBhbHJlYWR5LlxuICAgKi9cbiAgcHJpdmF0ZSBjb25kaXRpb25hbGx5SW5zZXJ0Q3NwTG9hZGluZ1NjcmlwdChkb2N1bWVudDogUGFydGlhbERvY3VtZW50LCBub25jZTogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuYWRkZWRDc3BTY3JpcHRzRG9jdW1lbnRzLmhhcyhkb2N1bWVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZG9jdW1lbnQuaGVhZC50ZXh0Q29udGVudC5pbmNsdWRlcyhMSU5LX0xPQURfU0NSSVBUX0NPTlRFTlQpKSB7XG4gICAgICAvLyBTY3JpcHQgd2FzIGFscmVhZHkgYWRkZWQgZHVyaW5nIHRoZSBidWlsZC5cbiAgICAgIHRoaXMuYWRkZWRDc3BTY3JpcHRzRG9jdW1lbnRzLmFkZChkb2N1bWVudCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICBzY3JpcHQuc2V0QXR0cmlidXRlKCdub25jZScsIG5vbmNlKTtcbiAgICBzY3JpcHQudGV4dENvbnRlbnQgPSBMSU5LX0xPQURfU0NSSVBUX0NPTlRFTlQ7XG5cbiAgICAvLyBBcHBlbmQgdGhlIHNjcmlwdCB0byB0aGUgaGVhZCBzaW5jZSBpdCBuZWVkcyB0b1xuICAgIC8vIHJ1biBhcyBlYXJseSBhcyBwb3NzaWJsZSwgYWZ0ZXIgdGhlIGBsaW5rYCB0YWdzLlxuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICB0aGlzLmFkZGVkQ3NwU2NyaXB0c0RvY3VtZW50cy5hZGQoZG9jdW1lbnQpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBJbmxpbmVDcml0aWNhbENzc1Byb2Nlc3NvciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgcmVzb3VyY2VDYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KCk7XG5cbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIHJlYWRvbmx5IG9wdGlvbnM6IElubGluZUNyaXRpY2FsQ3NzUHJvY2Vzc29yT3B0aW9ucykge31cblxuICBhc3luYyBwcm9jZXNzKFxuICAgIGh0bWw6IHN0cmluZyxcbiAgICBvcHRpb25zOiBJbmxpbmVDcml0aWNhbENzc1Byb2Nlc3NPcHRpb25zLFxuICApOiBQcm9taXNlPElubGluZUNyaXRpY2FsQ3NzUmVzdWx0PiB7XG4gICAgY29uc3QgY3JpdHRlcnMgPSBuZXcgQ3JpdHRlcnNFeHRlbmRlZCh7IC4uLnRoaXMub3B0aW9ucywgLi4ub3B0aW9ucyB9LCB0aGlzLnJlc291cmNlQ2FjaGUpO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCBjcml0dGVycy5wcm9jZXNzKGh0bWwpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRlbnQsXG4gICAgICBlcnJvcnM6IGNyaXR0ZXJzLmVycm9ycy5sZW5ndGggPyBjcml0dGVycy5lcnJvcnMgOiB1bmRlZmluZWQsXG4gICAgICB3YXJuaW5nczogY3JpdHRlcnMud2FybmluZ3MubGVuZ3RoID8gY3JpdHRlcnMud2FybmluZ3MgOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgfVxufVxuIl19