import { ɵgetDOM, DOCUMENT, ɵPLATFORM_SERVER_ID } from '@angular/common';
import * as i0 from '@angular/core';
import { APP_ID, Injectable, Inject, Optional, PLATFORM_ID, NgModule, makeStateKey } from '@angular/core';
import { ɵSharedStylesHost, BrowserModule } from '@angular/platform-browser';
import { filter, take, mapTo, tap } from 'rxjs/operators';
import { HttpResponse, HttpHeaders, HTTP_INTERCEPTORS } from '@angular/common/http';
import { of } from 'rxjs';

class SSRStylesHost extends ɵSharedStylesHost {
    constructor(document, applicationId = '') {
        super(document, applicationId);
        this.document = document;
        this.applicationId = applicationId;
        this._styleNodes = new Set();
        this.head = this.document.querySelector('head');
        const styles = this.head?.querySelectorAll(`style[ng-style='${this.applicationId}']`);
        if (styles?.length) {
            const items = Array.from(styles);
            this._styleNodesInDOM = new Map(items.map((el) => [el.textContent, el]));
        }
    }
    _addStyle(style) {
        const element = this._styleNodesInDOM?.get(style);
        if (element) {
            if (typeof ngDevMode !== 'undefined' && ngDevMode) {
                element.setAttribute('_ng-style-re-used', '');
            }
            this._styleNodesInDOM?.delete(style);
            this._styleNodes.add(element);
            return;
        }
        const el = ɵgetDOM().createElement('style');
        el.textContent = style;
        if (this.applicationId) {
            el.setAttribute('ng-style', this.applicationId);
        }
        if (this.head) {
            this.head.appendChild(el);
        }
        this._styleNodes.add(el);
    }
    onStylesAdded(additions) {
        additions.forEach((style) => this._addStyle(style));
    }
    addHost(_hostNode) {
        // stub
    }
    removeHost(_hostNode) {
        // stub
    }
    ngOnDestroy() {
        this._styleNodes.forEach((styleNode) => styleNode.remove());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.0", ngImport: i0, type: SSRStylesHost, deps: [{ token: DOCUMENT }, { token: APP_ID, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.0", ngImport: i0, type: SSRStylesHost }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.0", ngImport: i0, type: SSRStylesHost, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [APP_ID]
                }] }]; } });

/**
 * @deprecated This experimental API will be removed in version 16.
 * @experimental
 */
class RendererModule {
    constructor(applicationRef, transferState, appId) {
        this.applicationRef = applicationRef;
        this.transferState = transferState;
        this.appId = appId;
        if (typeof ngRenderMode !== 'undefined' && ngRenderMode) {
            ngRenderMode = {
                getSerializedState: () => this.transferState ? escapeHtml(this.transferState.toJson()) : undefined,
                appId: this.appId,
                getWhenStable: () => this.applicationRef.isStable
                    .pipe(filter((isStable) => isStable), take(1), mapTo(undefined))
                    .toPromise(),
            };
        }
    }
    static forRoot() {
        return {
            ngModule: RendererModule,
            providers: [
                ...(typeof ngRenderMode !== 'undefined' && ngRenderMode
                    ? [
                        { provide: PLATFORM_ID, useValue: ɵPLATFORM_SERVER_ID },
                        { provide: SSRStylesHost, useClass: SSRStylesHost, deps: [DOCUMENT, APP_ID] },
                    ]
                    : [{ provide: SSRStylesHost, useClass: SSRStylesHost, deps: [DOCUMENT] }]),
                { provide: ɵSharedStylesHost, useExisting: SSRStylesHost },
            ],
        };
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.0", ngImport: i0, type: RendererModule, deps: [{ token: i0.ApplicationRef }, { token: i0.TransferState, optional: true }, { token: APP_ID, optional: true }], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.0", ngImport: i0, type: RendererModule, exports: [BrowserModule] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.0", ngImport: i0, type: RendererModule, imports: [BrowserModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.0", ngImport: i0, type: RendererModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [BrowserModule],
                    imports: [],
                    providers: [],
                }]
        }], ctorParameters: function () { return [{ type: i0.ApplicationRef }, { type: i0.TransferState, decorators: [{
                    type: Optional
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [APP_ID]
                }] }]; } });
function escapeHtml(text) {
    const escapedText = {
        '&': '&a;',
        '"': '&q;',
        "'": '&s;',
        '<': '&l;',
        '>': '&g;',
    };
    return text.replace(/[&"'<>]/g, (s) => escapedText[s]);
}

class TransferHttpCacheInterceptor {
    makeCacheKey(method, url, params, responseType) {
        // make the params encoded same as a url so it's easy to identify
        const encodedParams = params
            .keys()
            .sort()
            .map((k) => `${k}=${params.getAll(k)}`)
            .join('&');
        const key = (method === 'GET' ? 'G.' : 'H.') + responseType + '.' + url + '?' + encodedParams;
        return makeStateKey(key);
    }
    constructor(appRef, transferState) {
        this.transferState = transferState;
        this.isCacheActive = true;
        // Stop using the cache if the application has stabilized, indicating initial rendering is
        // complete.
        appRef.isStable
            .pipe(filter((isStable) => isStable), take(1), tap(() => (this.isCacheActive = false)))
            .subscribe();
    }
    intercept(req, next) {
        if (!this.isCacheActive || !['GET', 'HEAD'].includes(req.method)) {
            // Cache is no longer active. Pass the request through.
            return next.handle(req);
        }
        const storeKey = this.makeCacheKey(req.method, req.url, req.params, req.responseType);
        const response = this.transferState.get(storeKey, null);
        if (response) {
            // Request found in cache. Respond using it.
            let body = response.body;
            switch (response.responseType) {
                case 'arraybuffer':
                    {
                        // If we're in Node...
                        if (typeof Buffer !== 'undefined') {
                            const buf = Buffer.from(response.body);
                            body = new ArrayBuffer(buf.length);
                            const view = new Uint8Array(body);
                            for (let i = 0; i < buf.length; ++i) {
                                view[i] = buf[i];
                            }
                        }
                        else if (typeof TextEncoder !== 'undefined') {
                            // Modern browsers implement TextEncode.
                            body = new TextEncoder().encode(response.body).buffer;
                        }
                    }
                    break;
                case 'blob':
                    body = new Blob([response.body]);
                    break;
            }
            return of(new HttpResponse({
                body,
                headers: new HttpHeaders(response.headers),
                status: response.status,
                statusText: response.statusText,
                url: response.url,
            }));
        }
        // Request not found in cache. Make the request and cache it.
        const httpEvent = next.handle(req);
        return httpEvent.pipe(tap((event) => {
            if (event instanceof HttpResponse) {
                this.transferState.set(storeKey, {
                    body: event.body,
                    headers: this.getHeaders(event.headers),
                    status: event.status,
                    statusText: event.statusText,
                    url: event.url ?? '',
                    responseType: req.responseType,
                });
            }
        }));
    }
    getHeaders(headers) {
        const headersMap = {};
        for (const key of headers.keys()) {
            const value = headers.getAll(key);
            if (typeof value === 'string') {
                headersMap[key] = value;
            }
        }
        return headersMap;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.0", ngImport: i0, type: TransferHttpCacheInterceptor, deps: [{ token: i0.ApplicationRef }, { token: i0.TransferState }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.0", ngImport: i0, type: TransferHttpCacheInterceptor }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.0", ngImport: i0, type: TransferHttpCacheInterceptor, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.ApplicationRef }, { type: i0.TransferState }]; } });

/**
 * @deprecated This experimental API will be removed in version 16.
 * @experimental
 */
class TransferHttpCacheModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.0", ngImport: i0, type: TransferHttpCacheModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.0", ngImport: i0, type: TransferHttpCacheModule }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.0", ngImport: i0, type: TransferHttpCacheModule, providers: [
            TransferHttpCacheInterceptor,
            { provide: HTTP_INTERCEPTORS, useExisting: TransferHttpCacheInterceptor, multi: true },
        ] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.0", ngImport: i0, type: TransferHttpCacheModule, decorators: [{
            type: NgModule,
            args: [{
                    providers: [
                        TransferHttpCacheInterceptor,
                        { provide: HTTP_INTERCEPTORS, useExisting: TransferHttpCacheInterceptor, multi: true },
                    ],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { RendererModule, TransferHttpCacheModule };
//# sourceMappingURL=clover.mjs.map
